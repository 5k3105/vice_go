// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Fri, 23 Jun 2017 22:04:27 MDT.
// By https://git.io/cgogen. DO NOT EDIT.

package vice

/*
#include "monitor.h"
#include "maincpu.h"
#include "mem.h"
#include "video.h"
#include "init.h"
#include "diskimage.h"
#include "debug.h"
#include "monitor/mon_breakpoint.h"
#include "c64/c64mem.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocMonitorCpuTypeMemory allocates memory for type C.monitor_cpu_type_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMonitorCpuTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMonitorCpuTypeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMonitorCpuTypeValue = unsafe.Sizeof([1]C.monitor_cpu_type_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MonitorCpuType) Ref() *C.monitor_cpu_type_t {
	if x == nil {
		return nil
	}
	return x.refc2a36abd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MonitorCpuType) Free() {
	if x != nil && x.allocsc2a36abd != nil {
		x.allocsc2a36abd.(*cgoAllocMap).Free()
		x.refc2a36abd = nil
	}
}

// NewMonitorCpuTypeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMonitorCpuTypeRef(ref unsafe.Pointer) *MonitorCpuType {
	if ref == nil {
		return nil
	}
	obj := new(MonitorCpuType)
	obj.refc2a36abd = (*C.monitor_cpu_type_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MonitorCpuType) PassRef() (*C.monitor_cpu_type_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc2a36abd != nil {
		return x.refc2a36abd, nil
	}
	memc2a36abd := allocMonitorCpuTypeMemory(1)
	refc2a36abd := (*C.monitor_cpu_type_t)(memc2a36abd)
	allocsc2a36abd := new(cgoAllocMap)
	var casm_addr_mode_get_size_allocs *cgoAllocMap
	refc2a36abd.asm_addr_mode_get_size, casm_addr_mode_get_size_allocs = x.AsmAddrModeGetSize.PassRef()
	allocsc2a36abd.Borrow(casm_addr_mode_get_size_allocs)

	var casm_opcode_info_get_allocs *cgoAllocMap
	refc2a36abd.asm_opcode_info_get, casm_opcode_info_get_allocs = x.AsmOpcodeInfoGet.PassRef()
	allocsc2a36abd.Borrow(casm_opcode_info_get_allocs)

	var cmon_assemble_instr_allocs *cgoAllocMap
	refc2a36abd.mon_assemble_instr, cmon_assemble_instr_allocs = x.MonAssembleInstr.PassRef()
	allocsc2a36abd.Borrow(cmon_assemble_instr_allocs)

	var cmon_register_get_val_allocs *cgoAllocMap
	refc2a36abd.mon_register_get_val, cmon_register_get_val_allocs = x.MonRegisterGetVal.PassRef()
	allocsc2a36abd.Borrow(cmon_register_get_val_allocs)

	var cmon_register_set_val_allocs *cgoAllocMap
	refc2a36abd.mon_register_set_val, cmon_register_set_val_allocs = x.MonRegisterSetVal.PassRef()
	allocsc2a36abd.Borrow(cmon_register_set_val_allocs)

	var cmon_register_print_allocs *cgoAllocMap
	refc2a36abd.mon_register_print, cmon_register_print_allocs = x.MonRegisterPrint.PassRef()
	allocsc2a36abd.Borrow(cmon_register_print_allocs)

	var cmon_register_print_ex_allocs *cgoAllocMap
	refc2a36abd.mon_register_print_ex, cmon_register_print_ex_allocs = x.MonRegisterPrintEx.PassRef()
	allocsc2a36abd.Borrow(cmon_register_print_ex_allocs)

	var cmon_register_list_get_allocs *cgoAllocMap
	refc2a36abd.mon_register_list_get, cmon_register_list_get_allocs = x.MonRegisterListGet.PassRef()
	allocsc2a36abd.Borrow(cmon_register_list_get_allocs)

	x.refc2a36abd = refc2a36abd
	x.allocsc2a36abd = allocsc2a36abd
	return refc2a36abd, allocsc2a36abd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MonitorCpuType) PassValue() (C.monitor_cpu_type_t, *cgoAllocMap) {
	if x.refc2a36abd != nil {
		return *x.refc2a36abd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MonitorCpuType) Deref() {
	if x.refc2a36abd == nil {
		return
	}
	x.AsmAddrModeGetSize = NewRef(unsafe.Pointer(x.refc2a36abd.asm_addr_mode_get_size))
	x.AsmOpcodeInfoGet = NewRef(unsafe.Pointer(x.refc2a36abd.asm_opcode_info_get))
	x.MonAssembleInstr = NewRef(unsafe.Pointer(x.refc2a36abd.mon_assemble_instr))
	x.MonRegisterGetVal = NewRef(unsafe.Pointer(x.refc2a36abd.mon_register_get_val))
	x.MonRegisterSetVal = NewRef(unsafe.Pointer(x.refc2a36abd.mon_register_set_val))
	x.MonRegisterPrint = NewRef(unsafe.Pointer(x.refc2a36abd.mon_register_print))
	x.MonRegisterPrintEx = NewRef(unsafe.Pointer(x.refc2a36abd.mon_register_print_ex))
	x.MonRegisterListGet = NewRef(unsafe.Pointer(x.refc2a36abd.mon_register_list_get))
}

// allocMonitorInterfaceMemory allocates memory for type C.monitor_interface_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMonitorInterfaceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMonitorInterfaceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMonitorInterfaceValue = unsafe.Sizeof([1]C.monitor_interface_t{})

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MonitorInterface) Ref() *C.monitor_interface_t {
	if x == nil {
		return nil
	}
	return x.ref5ef17d6f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MonitorInterface) Free() {
	if x != nil && x.allocs5ef17d6f != nil {
		x.allocs5ef17d6f.(*cgoAllocMap).Free()
		x.ref5ef17d6f = nil
	}
}

// NewMonitorInterfaceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMonitorInterfaceRef(ref unsafe.Pointer) *MonitorInterface {
	if ref == nil {
		return nil
	}
	obj := new(MonitorInterface)
	obj.ref5ef17d6f = (*C.monitor_interface_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MonitorInterface) PassRef() (*C.monitor_interface_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ef17d6f != nil {
		return x.ref5ef17d6f, nil
	}
	mem5ef17d6f := allocMonitorInterfaceMemory(1)
	ref5ef17d6f := (*C.monitor_interface_t)(mem5ef17d6f)
	allocs5ef17d6f := new(cgoAllocMap)
	var cclk_allocs *cgoAllocMap
	ref5ef17d6f.clk, cclk_allocs = (*C.CLOCK)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Clk)).Data)), cgoAllocsUnknown
	allocs5ef17d6f.Borrow(cclk_allocs)

	var ccurrent_bank_allocs *cgoAllocMap
	ref5ef17d6f.current_bank, ccurrent_bank_allocs = (C.int)(x.CurrentBank), cgoAllocsUnknown
	allocs5ef17d6f.Borrow(ccurrent_bank_allocs)

	var cmem_bank_list_allocs *cgoAllocMap
	ref5ef17d6f.mem_bank_list, cmem_bank_list_allocs = x.MemBankList.PassRef()
	allocs5ef17d6f.Borrow(cmem_bank_list_allocs)

	var cmem_bank_from_name_allocs *cgoAllocMap
	ref5ef17d6f.mem_bank_from_name, cmem_bank_from_name_allocs = x.MemBankFromName.PassRef()
	allocs5ef17d6f.Borrow(cmem_bank_from_name_allocs)

	var cmem_bank_read_allocs *cgoAllocMap
	ref5ef17d6f.mem_bank_read, cmem_bank_read_allocs = x.MemBankRead.PassRef()
	allocs5ef17d6f.Borrow(cmem_bank_read_allocs)

	var cmem_bank_peek_allocs *cgoAllocMap
	ref5ef17d6f.mem_bank_peek, cmem_bank_peek_allocs = x.MemBankPeek.PassRef()
	allocs5ef17d6f.Borrow(cmem_bank_peek_allocs)

	var cmem_bank_write_allocs *cgoAllocMap
	ref5ef17d6f.mem_bank_write, cmem_bank_write_allocs = x.MemBankWrite.PassRef()
	allocs5ef17d6f.Borrow(cmem_bank_write_allocs)

	var cmem_ioreg_list_get_allocs *cgoAllocMap
	ref5ef17d6f.mem_ioreg_list_get, cmem_ioreg_list_get_allocs = x.MemIoregListGet.PassRef()
	allocs5ef17d6f.Borrow(cmem_ioreg_list_get_allocs)

	var ctoggle_watchpoints_func_allocs *cgoAllocMap
	ref5ef17d6f.toggle_watchpoints_func, ctoggle_watchpoints_func_allocs = x.ToggleWatchpointsFunc.PassRef()
	allocs5ef17d6f.Borrow(ctoggle_watchpoints_func_allocs)

	var cset_bank_base_allocs *cgoAllocMap
	ref5ef17d6f.set_bank_base, cset_bank_base_allocs = x.SetBankBase.PassRef()
	allocs5ef17d6f.Borrow(cset_bank_base_allocs)

	var cget_line_cycle_allocs *cgoAllocMap
	ref5ef17d6f.get_line_cycle, cget_line_cycle_allocs = x.GetLineCycle.PassRef()
	allocs5ef17d6f.Borrow(cget_line_cycle_allocs)

	var ccontext_allocs *cgoAllocMap
	ref5ef17d6f.context, ccontext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Context)), cgoAllocsUnknown
	allocs5ef17d6f.Borrow(ccontext_allocs)

	x.ref5ef17d6f = ref5ef17d6f
	x.allocs5ef17d6f = allocs5ef17d6f
	return ref5ef17d6f, allocs5ef17d6f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MonitorInterface) PassValue() (C.monitor_interface_t, *cgoAllocMap) {
	if x.ref5ef17d6f != nil {
		return *x.ref5ef17d6f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MonitorInterface) Deref() {
	if x.ref5ef17d6f == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Clk))
	hxfc4425b.Data = uintptr(unsafe.Pointer(x.ref5ef17d6f.clk))
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.CurrentBank = (int32)(x.ref5ef17d6f.current_bank)
	x.MemBankList = NewRef(unsafe.Pointer(x.ref5ef17d6f.mem_bank_list))
	x.MemBankFromName = NewRef(unsafe.Pointer(x.ref5ef17d6f.mem_bank_from_name))
	x.MemBankRead = NewRef(unsafe.Pointer(x.ref5ef17d6f.mem_bank_read))
	x.MemBankPeek = NewRef(unsafe.Pointer(x.ref5ef17d6f.mem_bank_peek))
	x.MemBankWrite = NewRef(unsafe.Pointer(x.ref5ef17d6f.mem_bank_write))
	x.MemIoregListGet = NewRef(unsafe.Pointer(x.ref5ef17d6f.mem_ioreg_list_get))
	x.ToggleWatchpointsFunc = NewRef(unsafe.Pointer(x.ref5ef17d6f.toggle_watchpoints_func))
	x.SetBankBase = NewRef(unsafe.Pointer(x.ref5ef17d6f.set_bank_base))
	x.GetLineCycle = NewRef(unsafe.Pointer(x.ref5ef17d6f.get_line_cycle))
	x.Context = (unsafe.Pointer)(unsafe.Pointer(x.ref5ef17d6f.context))
}

// allocMonitorCartridgeCommandsMemory allocates memory for type C.monitor_cartridge_commands_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMonitorCartridgeCommandsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMonitorCartridgeCommandsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMonitorCartridgeCommandsValue = unsafe.Sizeof([1]C.monitor_cartridge_commands_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MonitorCartridgeCommands) Ref() *C.monitor_cartridge_commands_t {
	if x == nil {
		return nil
	}
	return x.refb6ad82c6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MonitorCartridgeCommands) Free() {
	if x != nil && x.allocsb6ad82c6 != nil {
		x.allocsb6ad82c6.(*cgoAllocMap).Free()
		x.refb6ad82c6 = nil
	}
}

// NewMonitorCartridgeCommandsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMonitorCartridgeCommandsRef(ref unsafe.Pointer) *MonitorCartridgeCommands {
	if ref == nil {
		return nil
	}
	obj := new(MonitorCartridgeCommands)
	obj.refb6ad82c6 = (*C.monitor_cartridge_commands_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MonitorCartridgeCommands) PassRef() (*C.monitor_cartridge_commands_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb6ad82c6 != nil {
		return x.refb6ad82c6, nil
	}
	memb6ad82c6 := allocMonitorCartridgeCommandsMemory(1)
	refb6ad82c6 := (*C.monitor_cartridge_commands_t)(memb6ad82c6)
	allocsb6ad82c6 := new(cgoAllocMap)
	var ccartridge_attach_image_allocs *cgoAllocMap
	refb6ad82c6.cartridge_attach_image, ccartridge_attach_image_allocs = x.CartridgeAttachImage.PassRef()
	allocsb6ad82c6.Borrow(ccartridge_attach_image_allocs)

	var ccartridge_detach_image_allocs *cgoAllocMap
	refb6ad82c6.cartridge_detach_image, ccartridge_detach_image_allocs = x.CartridgeDetachImage.PassRef()
	allocsb6ad82c6.Borrow(ccartridge_detach_image_allocs)

	var ccartridge_trigger_freeze_allocs *cgoAllocMap
	refb6ad82c6.cartridge_trigger_freeze, ccartridge_trigger_freeze_allocs = x.CartridgeTriggerFreeze.PassRef()
	allocsb6ad82c6.Borrow(ccartridge_trigger_freeze_allocs)

	var ccartridge_trigger_freeze_nmi_only_allocs *cgoAllocMap
	refb6ad82c6.cartridge_trigger_freeze_nmi_only, ccartridge_trigger_freeze_nmi_only_allocs = x.CartridgeTriggerFreezeNmiOnly.PassRef()
	allocsb6ad82c6.Borrow(ccartridge_trigger_freeze_nmi_only_allocs)

	var cexport_dump_allocs *cgoAllocMap
	refb6ad82c6.export_dump, cexport_dump_allocs = x.ExportDump.PassRef()
	allocsb6ad82c6.Borrow(cexport_dump_allocs)

	x.refb6ad82c6 = refb6ad82c6
	x.allocsb6ad82c6 = allocsb6ad82c6
	return refb6ad82c6, allocsb6ad82c6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MonitorCartridgeCommands) PassValue() (C.monitor_cartridge_commands_t, *cgoAllocMap) {
	if x.refb6ad82c6 != nil {
		return *x.refb6ad82c6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MonitorCartridgeCommands) Deref() {
	if x.refb6ad82c6 == nil {
		return
	}
	x.CartridgeAttachImage = NewRef(unsafe.Pointer(x.refb6ad82c6.cartridge_attach_image))
	x.CartridgeDetachImage = NewRef(unsafe.Pointer(x.refb6ad82c6.cartridge_detach_image))
	x.CartridgeTriggerFreeze = NewRef(unsafe.Pointer(x.refb6ad82c6.cartridge_trigger_freeze))
	x.CartridgeTriggerFreezeNmiOnly = NewRef(unsafe.Pointer(x.refb6ad82c6.cartridge_trigger_freeze_nmi_only))
	x.ExportDump = NewRef(unsafe.Pointer(x.refb6ad82c6.export_dump))
}

// allocMemIoregListMemory allocates memory for type C.mem_ioreg_list_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemIoregListMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemIoregListValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemIoregListValue = unsafe.Sizeof([1]C.mem_ioreg_list_t{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemIoregList) Ref() *C.mem_ioreg_list_t {
	if x == nil {
		return nil
	}
	return x.ref8ed5165d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemIoregList) Free() {
	if x != nil && x.allocs8ed5165d != nil {
		x.allocs8ed5165d.(*cgoAllocMap).Free()
		x.ref8ed5165d = nil
	}
}

// NewMemIoregListRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemIoregListRef(ref unsafe.Pointer) *MemIoregList {
	if ref == nil {
		return nil
	}
	obj := new(MemIoregList)
	obj.ref8ed5165d = (*C.mem_ioreg_list_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemIoregList) PassRef() (*C.mem_ioreg_list_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8ed5165d != nil {
		return x.ref8ed5165d, nil
	}
	mem8ed5165d := allocMemIoregListMemory(1)
	ref8ed5165d := (*C.mem_ioreg_list_t)(mem8ed5165d)
	allocs8ed5165d := new(cgoAllocMap)
	var cname_allocs *cgoAllocMap
	ref8ed5165d.name, cname_allocs = unpackPCharString(x.Name)
	allocs8ed5165d.Borrow(cname_allocs)

	var cstart_allocs *cgoAllocMap
	ref8ed5165d.start, cstart_allocs = (C.WORD)(x.Start), cgoAllocsUnknown
	allocs8ed5165d.Borrow(cstart_allocs)

	var cend_allocs *cgoAllocMap
	ref8ed5165d.end, cend_allocs = (C.WORD)(x.End), cgoAllocsUnknown
	allocs8ed5165d.Borrow(cend_allocs)

	var cnext_allocs *cgoAllocMap
	ref8ed5165d.next, cnext_allocs = (C.uint)(x.Next), cgoAllocsUnknown
	allocs8ed5165d.Borrow(cnext_allocs)

	var cdump_allocs *cgoAllocMap
	ref8ed5165d.dump, cdump_allocs = x.Dump.PassRef()
	allocs8ed5165d.Borrow(cdump_allocs)

	var ccontext_allocs *cgoAllocMap
	ref8ed5165d.context, ccontext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Context)), cgoAllocsUnknown
	allocs8ed5165d.Borrow(ccontext_allocs)

	x.ref8ed5165d = ref8ed5165d
	x.allocs8ed5165d = allocs8ed5165d
	return ref8ed5165d, allocs8ed5165d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemIoregList) PassValue() (C.mem_ioreg_list_t, *cgoAllocMap) {
	if x.ref8ed5165d != nil {
		return *x.ref8ed5165d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemIoregList) Deref() {
	if x.ref8ed5165d == nil {
		return
	}
	x.Name = packPCharString(x.ref8ed5165d.name)
	x.Start = (uint16)(x.ref8ed5165d.start)
	x.End = (uint16)(x.ref8ed5165d.end)
	x.Next = (uint32)(x.ref8ed5165d.next)
	x.Dump = NewRef(unsafe.Pointer(x.ref8ed5165d.dump))
	x.Context = (unsafe.Pointer)(unsafe.Pointer(x.ref8ed5165d.context))
}

// allocVideoChipCapMemory allocates memory for type C.video_chip_cap_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoChipCapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoChipCapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVideoChipCapValue = unsafe.Sizeof([1]C.video_chip_cap_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoChipCap) Ref() *C.video_chip_cap_t {
	if x == nil {
		return nil
	}
	return x.ref3e03c83
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoChipCap) Free() {
	if x != nil && x.allocs3e03c83 != nil {
		x.allocs3e03c83.(*cgoAllocMap).Free()
		x.ref3e03c83 = nil
	}
}

// NewVideoChipCapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoChipCapRef(ref unsafe.Pointer) *VideoChipCap {
	if ref == nil {
		return nil
	}
	obj := new(VideoChipCap)
	obj.ref3e03c83 = (*C.video_chip_cap_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoChipCap) PassRef() (*C.video_chip_cap_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3e03c83 != nil {
		return x.ref3e03c83, nil
	}
	mem3e03c83 := allocVideoChipCapMemory(1)
	ref3e03c83 := (*C.video_chip_cap_t)(mem3e03c83)
	allocs3e03c83 := new(cgoAllocMap)
	var cdsize_allowed_allocs *cgoAllocMap
	ref3e03c83.dsize_allowed, cdsize_allowed_allocs = (C.uint)(x.DsizeAllowed), cgoAllocsUnknown
	allocs3e03c83.Borrow(cdsize_allowed_allocs)

	var cdsize_default_allocs *cgoAllocMap
	ref3e03c83.dsize_default, cdsize_default_allocs = (C.uint)(x.DsizeDefault), cgoAllocsUnknown
	allocs3e03c83.Borrow(cdsize_default_allocs)

	var cdsize_limit_width_allocs *cgoAllocMap
	ref3e03c83.dsize_limit_width, cdsize_limit_width_allocs = (C.uint)(x.DsizeLimitWidth), cgoAllocsUnknown
	allocs3e03c83.Borrow(cdsize_limit_width_allocs)

	var cdsize_limit_height_allocs *cgoAllocMap
	ref3e03c83.dsize_limit_height, cdsize_limit_height_allocs = (C.uint)(x.DsizeLimitHeight), cgoAllocsUnknown
	allocs3e03c83.Borrow(cdsize_limit_height_allocs)

	var cdscan_allowed_allocs *cgoAllocMap
	ref3e03c83.dscan_allowed, cdscan_allowed_allocs = (C.uint)(x.DscanAllowed), cgoAllocsUnknown
	allocs3e03c83.Borrow(cdscan_allowed_allocs)

	var chwscale_allowed_allocs *cgoAllocMap
	ref3e03c83.hwscale_allowed, chwscale_allowed_allocs = (C.uint)(x.HwscaleAllowed), cgoAllocsUnknown
	allocs3e03c83.Borrow(chwscale_allowed_allocs)

	var cscale2x_allowed_allocs *cgoAllocMap
	ref3e03c83.scale2x_allowed, cscale2x_allowed_allocs = (C.uint)(x.Scale2xAllowed), cgoAllocsUnknown
	allocs3e03c83.Borrow(cscale2x_allowed_allocs)

	var cdouble_buffering_allowed_allocs *cgoAllocMap
	ref3e03c83.double_buffering_allowed, cdouble_buffering_allowed_allocs = (C.uint)(x.DoubleBufferingAllowed), cgoAllocsUnknown
	allocs3e03c83.Borrow(cdouble_buffering_allowed_allocs)

	var cexternal_palette_name_allocs *cgoAllocMap
	ref3e03c83.external_palette_name, cexternal_palette_name_allocs = unpackPCharString(x.ExternalPaletteName)
	allocs3e03c83.Borrow(cexternal_palette_name_allocs)

	x.ref3e03c83 = ref3e03c83
	x.allocs3e03c83 = allocs3e03c83
	return ref3e03c83, allocs3e03c83

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoChipCap) PassValue() (C.video_chip_cap_t, *cgoAllocMap) {
	if x.ref3e03c83 != nil {
		return *x.ref3e03c83, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoChipCap) Deref() {
	if x.ref3e03c83 == nil {
		return
	}
	x.DsizeAllowed = (uint32)(x.ref3e03c83.dsize_allowed)
	x.DsizeDefault = (uint32)(x.ref3e03c83.dsize_default)
	x.DsizeLimitWidth = (uint32)(x.ref3e03c83.dsize_limit_width)
	x.DsizeLimitHeight = (uint32)(x.ref3e03c83.dsize_limit_height)
	x.DscanAllowed = (uint32)(x.ref3e03c83.dscan_allowed)
	x.HwscaleAllowed = (uint32)(x.ref3e03c83.hwscale_allowed)
	x.Scale2xAllowed = (uint32)(x.ref3e03c83.scale2x_allowed)
	x.DoubleBufferingAllowed = (uint32)(x.ref3e03c83.double_buffering_allowed)
	x.ExternalPaletteName = packPCharString(x.ref3e03c83.external_palette_name)
}

// allocVideoRenderColorTablesMemory allocates memory for type C.video_render_color_tables_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoRenderColorTablesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoRenderColorTablesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVideoRenderColorTablesValue = unsafe.Sizeof([1]C.video_render_color_tables_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoRenderColorTables) Ref() *C.video_render_color_tables_t {
	if x == nil {
		return nil
	}
	return x.ref8b09ecf5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoRenderColorTables) Free() {
	if x != nil && x.allocs8b09ecf5 != nil {
		x.allocs8b09ecf5.(*cgoAllocMap).Free()
		x.ref8b09ecf5 = nil
	}
}

// NewVideoRenderColorTablesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoRenderColorTablesRef(ref unsafe.Pointer) *VideoRenderColorTables {
	if ref == nil {
		return nil
	}
	obj := new(VideoRenderColorTables)
	obj.ref8b09ecf5 = (*C.video_render_color_tables_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoRenderColorTables) PassRef() (*C.video_render_color_tables_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8b09ecf5 != nil {
		return x.ref8b09ecf5, nil
	}
	mem8b09ecf5 := allocVideoRenderColorTablesMemory(1)
	ref8b09ecf5 := (*C.video_render_color_tables_t)(mem8b09ecf5)
	allocs8b09ecf5 := new(cgoAllocMap)
	var cupdated_allocs *cgoAllocMap
	ref8b09ecf5.updated, cupdated_allocs = (C.int)(x.Updated), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(cupdated_allocs)

	var cphysical_colors_allocs *cgoAllocMap
	ref8b09ecf5.physical_colors, cphysical_colors_allocs = *(*[256]C.DWORD)(unsafe.Pointer(&x.PhysicalColors)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(cphysical_colors_allocs)

	var cytableh_allocs *cgoAllocMap
	ref8b09ecf5.ytableh, cytableh_allocs = *(*[256]C.SDWORD)(unsafe.Pointer(&x.Ytableh)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(cytableh_allocs)

	var cytablel_allocs *cgoAllocMap
	ref8b09ecf5.ytablel, cytablel_allocs = *(*[256]C.SDWORD)(unsafe.Pointer(&x.Ytablel)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(cytablel_allocs)

	var ccbtable_allocs *cgoAllocMap
	ref8b09ecf5.cbtable, ccbtable_allocs = *(*[256]C.SDWORD)(unsafe.Pointer(&x.Cbtable)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(ccbtable_allocs)

	var ccbtable_odd_allocs *cgoAllocMap
	ref8b09ecf5.cbtable_odd, ccbtable_odd_allocs = *(*[256]C.SDWORD)(unsafe.Pointer(&x.CbtableOdd)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(ccbtable_odd_allocs)

	var ccrtable_allocs *cgoAllocMap
	ref8b09ecf5.crtable, ccrtable_allocs = *(*[256]C.SDWORD)(unsafe.Pointer(&x.Crtable)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(ccrtable_allocs)

	var ccrtable_odd_allocs *cgoAllocMap
	ref8b09ecf5.crtable_odd, ccrtable_odd_allocs = *(*[256]C.SDWORD)(unsafe.Pointer(&x.CrtableOdd)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(ccrtable_odd_allocs)

	var ccutable_allocs *cgoAllocMap
	ref8b09ecf5.cutable, ccutable_allocs = *(*[256]C.SDWORD)(unsafe.Pointer(&x.Cutable)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(ccutable_allocs)

	var ccutable_odd_allocs *cgoAllocMap
	ref8b09ecf5.cutable_odd, ccutable_odd_allocs = *(*[256]C.SDWORD)(unsafe.Pointer(&x.CutableOdd)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(ccutable_odd_allocs)

	var ccvtable_allocs *cgoAllocMap
	ref8b09ecf5.cvtable, ccvtable_allocs = *(*[256]C.SDWORD)(unsafe.Pointer(&x.Cvtable)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(ccvtable_allocs)

	var ccvtable_odd_allocs *cgoAllocMap
	ref8b09ecf5.cvtable_odd, ccvtable_odd_allocs = *(*[256]C.SDWORD)(unsafe.Pointer(&x.CvtableOdd)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(ccvtable_odd_allocs)

	var cyuv_updated_allocs *cgoAllocMap
	ref8b09ecf5.yuv_updated, cyuv_updated_allocs = (C.int)(x.YuvUpdated), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(cyuv_updated_allocs)

	var cyuv_table_allocs *cgoAllocMap
	ref8b09ecf5.yuv_table, cyuv_table_allocs = *(*[512]C.DWORD)(unsafe.Pointer(&x.YuvTable)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(cyuv_table_allocs)

	var cline_yuv_0_allocs *cgoAllocMap
	ref8b09ecf5.line_yuv_0, cline_yuv_0_allocs = *(*[6144]C.SDWORD)(unsafe.Pointer(&x.LineYuv0)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(cline_yuv_0_allocs)

	var cprevrgbline_allocs *cgoAllocMap
	ref8b09ecf5.prevrgbline, cprevrgbline_allocs = *(*[6144]C.SWORD)(unsafe.Pointer(&x.Prevrgbline)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(cprevrgbline_allocs)

	var crgbscratchbuffer_allocs *cgoAllocMap
	ref8b09ecf5.rgbscratchbuffer, crgbscratchbuffer_allocs = *(*[8192]C.uchar)(unsafe.Pointer(&x.Rgbscratchbuffer)), cgoAllocsUnknown
	allocs8b09ecf5.Borrow(crgbscratchbuffer_allocs)

	x.ref8b09ecf5 = ref8b09ecf5
	x.allocs8b09ecf5 = allocs8b09ecf5
	return ref8b09ecf5, allocs8b09ecf5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoRenderColorTables) PassValue() (C.video_render_color_tables_t, *cgoAllocMap) {
	if x.ref8b09ecf5 != nil {
		return *x.ref8b09ecf5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoRenderColorTables) Deref() {
	if x.ref8b09ecf5 == nil {
		return
	}
	x.Updated = (int32)(x.ref8b09ecf5.updated)
	x.PhysicalColors = *(*[256]uint32)(unsafe.Pointer(&x.ref8b09ecf5.physical_colors))
	x.Ytableh = *(*[256]int32)(unsafe.Pointer(&x.ref8b09ecf5.ytableh))
	x.Ytablel = *(*[256]int32)(unsafe.Pointer(&x.ref8b09ecf5.ytablel))
	x.Cbtable = *(*[256]int32)(unsafe.Pointer(&x.ref8b09ecf5.cbtable))
	x.CbtableOdd = *(*[256]int32)(unsafe.Pointer(&x.ref8b09ecf5.cbtable_odd))
	x.Crtable = *(*[256]int32)(unsafe.Pointer(&x.ref8b09ecf5.crtable))
	x.CrtableOdd = *(*[256]int32)(unsafe.Pointer(&x.ref8b09ecf5.crtable_odd))
	x.Cutable = *(*[256]int32)(unsafe.Pointer(&x.ref8b09ecf5.cutable))
	x.CutableOdd = *(*[256]int32)(unsafe.Pointer(&x.ref8b09ecf5.cutable_odd))
	x.Cvtable = *(*[256]int32)(unsafe.Pointer(&x.ref8b09ecf5.cvtable))
	x.CvtableOdd = *(*[256]int32)(unsafe.Pointer(&x.ref8b09ecf5.cvtable_odd))
	x.YuvUpdated = (int32)(x.ref8b09ecf5.yuv_updated)
	x.YuvTable = *(*[512]uint32)(unsafe.Pointer(&x.ref8b09ecf5.yuv_table))
	x.LineYuv0 = *(*[6144]int32)(unsafe.Pointer(&x.ref8b09ecf5.line_yuv_0))
	x.Prevrgbline = *(*[6144]int16)(unsafe.Pointer(&x.ref8b09ecf5.prevrgbline))
	x.Rgbscratchbuffer = *(*[8192]byte)(unsafe.Pointer(&x.ref8b09ecf5.rgbscratchbuffer))
}

// allocVideoResourcesMemory allocates memory for type C.video_resources_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoResourcesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoResourcesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVideoResourcesValue = unsafe.Sizeof([1]C.video_resources_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoResources) Ref() *C.video_resources_t {
	if x == nil {
		return nil
	}
	return x.refe4c1211
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoResources) Free() {
	if x != nil && x.allocse4c1211 != nil {
		x.allocse4c1211.(*cgoAllocMap).Free()
		x.refe4c1211 = nil
	}
}

// NewVideoResourcesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoResourcesRef(ref unsafe.Pointer) *VideoResources {
	if ref == nil {
		return nil
	}
	obj := new(VideoResources)
	obj.refe4c1211 = (*C.video_resources_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoResources) PassRef() (*C.video_resources_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe4c1211 != nil {
		return x.refe4c1211, nil
	}
	meme4c1211 := allocVideoResourcesMemory(1)
	refe4c1211 := (*C.video_resources_t)(meme4c1211)
	allocse4c1211 := new(cgoAllocMap)
	var ccolor_saturation_allocs *cgoAllocMap
	refe4c1211.color_saturation, ccolor_saturation_allocs = (C.int)(x.ColorSaturation), cgoAllocsUnknown
	allocse4c1211.Borrow(ccolor_saturation_allocs)

	var ccolor_contrast_allocs *cgoAllocMap
	refe4c1211.color_contrast, ccolor_contrast_allocs = (C.int)(x.ColorContrast), cgoAllocsUnknown
	allocse4c1211.Borrow(ccolor_contrast_allocs)

	var ccolor_brightness_allocs *cgoAllocMap
	refe4c1211.color_brightness, ccolor_brightness_allocs = (C.int)(x.ColorBrightness), cgoAllocsUnknown
	allocse4c1211.Borrow(ccolor_brightness_allocs)

	var ccolor_gamma_allocs *cgoAllocMap
	refe4c1211.color_gamma, ccolor_gamma_allocs = (C.int)(x.ColorGamma), cgoAllocsUnknown
	allocse4c1211.Borrow(ccolor_gamma_allocs)

	var ccolor_tint_allocs *cgoAllocMap
	refe4c1211.color_tint, ccolor_tint_allocs = (C.int)(x.ColorTint), cgoAllocsUnknown
	allocse4c1211.Borrow(ccolor_tint_allocs)

	var cpal_scanlineshade_allocs *cgoAllocMap
	refe4c1211.pal_scanlineshade, cpal_scanlineshade_allocs = (C.int)(x.PalScanlineshade), cgoAllocsUnknown
	allocse4c1211.Borrow(cpal_scanlineshade_allocs)

	var cpal_blur_allocs *cgoAllocMap
	refe4c1211.pal_blur, cpal_blur_allocs = (C.int)(x.PalBlur), cgoAllocsUnknown
	allocse4c1211.Borrow(cpal_blur_allocs)

	var cpal_oddlines_phase_allocs *cgoAllocMap
	refe4c1211.pal_oddlines_phase, cpal_oddlines_phase_allocs = (C.int)(x.PalOddlinesPhase), cgoAllocsUnknown
	allocse4c1211.Borrow(cpal_oddlines_phase_allocs)

	var cpal_oddlines_offset_allocs *cgoAllocMap
	refe4c1211.pal_oddlines_offset, cpal_oddlines_offset_allocs = (C.int)(x.PalOddlinesOffset), cgoAllocsUnknown
	allocse4c1211.Borrow(cpal_oddlines_offset_allocs)

	var caudioleak_allocs *cgoAllocMap
	refe4c1211.audioleak, caudioleak_allocs = (C.int)(x.Audioleak), cgoAllocsUnknown
	allocse4c1211.Borrow(caudioleak_allocs)

	x.refe4c1211 = refe4c1211
	x.allocse4c1211 = allocse4c1211
	return refe4c1211, allocse4c1211

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoResources) PassValue() (C.video_resources_t, *cgoAllocMap) {
	if x.refe4c1211 != nil {
		return *x.refe4c1211, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoResources) Deref() {
	if x.refe4c1211 == nil {
		return
	}
	x.ColorSaturation = (int32)(x.refe4c1211.color_saturation)
	x.ColorContrast = (int32)(x.refe4c1211.color_contrast)
	x.ColorBrightness = (int32)(x.refe4c1211.color_brightness)
	x.ColorGamma = (int32)(x.refe4c1211.color_gamma)
	x.ColorTint = (int32)(x.refe4c1211.color_tint)
	x.PalScanlineshade = (int32)(x.refe4c1211.pal_scanlineshade)
	x.PalBlur = (int32)(x.refe4c1211.pal_blur)
	x.PalOddlinesPhase = (int32)(x.refe4c1211.pal_oddlines_phase)
	x.PalOddlinesOffset = (int32)(x.refe4c1211.pal_oddlines_offset)
	x.Audioleak = (int32)(x.refe4c1211.audioleak)
}

// allocVideoRenderConfigMemory allocates memory for type C.video_render_config_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoRenderConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoRenderConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVideoRenderConfigValue = unsafe.Sizeof([1]C.video_render_config_t{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSVideoChipCap transforms a sliced Go data structure into plain C format.
func unpackSVideoChipCap(x []VideoChipCap) (unpacked *C.video_chip_cap_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.video_chip_cap_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVideoChipCapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.video_chip_cap_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.video_chip_cap_t)(unsafe.Pointer(h.Data))
	return
}

// allocStructVideoCbmPaletteSMemory allocates memory for type C.struct_video_cbm_palette_s in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructVideoCbmPaletteSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructVideoCbmPaletteSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructVideoCbmPaletteSValue = unsafe.Sizeof([1]C.struct_video_cbm_palette_s{})

// unpackSVideoCbmPaletteS transforms a sliced Go data structure into plain C format.
func unpackSVideoCbmPaletteS(x []VideoCbmPaletteS) (unpacked *C.struct_video_cbm_palette_s, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_video_cbm_palette_s) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructVideoCbmPaletteSMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_video_cbm_palette_s)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_video_cbm_palette_s)(unsafe.Pointer(h.Data))
	return
}

// packSVideoChipCap reads sliced Go data structure out from plain C format.
func packSVideoChipCap(v []VideoChipCap, ptr0 *C.video_chip_cap_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVideoChipCapValue]C.video_chip_cap_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVideoChipCapRef(unsafe.Pointer(&ptr1))
	}
}

// packSVideoCbmPaletteS reads sliced Go data structure out from plain C format.
func packSVideoCbmPaletteS(v []VideoCbmPaletteS, ptr0 *C.struct_video_cbm_palette_s) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructVideoCbmPaletteSValue]C.struct_video_cbm_palette_s)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVideoCbmPaletteSRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoRenderConfig) Ref() *C.video_render_config_t {
	if x == nil {
		return nil
	}
	return x.ref5b975e14
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoRenderConfig) Free() {
	if x != nil && x.allocs5b975e14 != nil {
		x.allocs5b975e14.(*cgoAllocMap).Free()
		x.ref5b975e14 = nil
	}
}

// NewVideoRenderConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoRenderConfigRef(ref unsafe.Pointer) *VideoRenderConfig {
	if ref == nil {
		return nil
	}
	obj := new(VideoRenderConfig)
	obj.ref5b975e14 = (*C.video_render_config_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoRenderConfig) PassRef() (*C.video_render_config_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5b975e14 != nil {
		return x.ref5b975e14, nil
	}
	mem5b975e14 := allocVideoRenderConfigMemory(1)
	ref5b975e14 := (*C.video_render_config_t)(mem5b975e14)
	allocs5b975e14 := new(cgoAllocMap)
	var cchip_name_allocs *cgoAllocMap
	ref5b975e14.chip_name, cchip_name_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.ChipName)).Data)), cgoAllocsUnknown
	allocs5b975e14.Borrow(cchip_name_allocs)

	var cvideo_resources_allocs *cgoAllocMap
	ref5b975e14.video_resources, cvideo_resources_allocs = x.VideoResources.PassValue()
	allocs5b975e14.Borrow(cvideo_resources_allocs)

	var ccap_allocs *cgoAllocMap
	ref5b975e14.cap, ccap_allocs = unpackSVideoChipCap(x.Cap)
	allocs5b975e14.Borrow(ccap_allocs)

	var crendermode_allocs *cgoAllocMap
	ref5b975e14.rendermode, crendermode_allocs = (C.int)(x.Rendermode), cgoAllocsUnknown
	allocs5b975e14.Borrow(crendermode_allocs)

	var cdouble_size_enabled_allocs *cgoAllocMap
	ref5b975e14.double_size_enabled, cdouble_size_enabled_allocs = (C.int)(x.DoubleSizeEnabled), cgoAllocsUnknown
	allocs5b975e14.Borrow(cdouble_size_enabled_allocs)

	var cscalex_allocs *cgoAllocMap
	ref5b975e14.scalex, cscalex_allocs = (C.int)(x.Scalex), cgoAllocsUnknown
	allocs5b975e14.Borrow(cscalex_allocs)

	var cscaley_allocs *cgoAllocMap
	ref5b975e14.scaley, cscaley_allocs = (C.int)(x.Scaley), cgoAllocsUnknown
	allocs5b975e14.Borrow(cscaley_allocs)

	var cdoublescan_allocs *cgoAllocMap
	ref5b975e14.doublescan, cdoublescan_allocs = (C.int)(x.Doublescan), cgoAllocsUnknown
	allocs5b975e14.Borrow(cdoublescan_allocs)

	var chwscale_allocs *cgoAllocMap
	ref5b975e14.hwscale, chwscale_allocs = (C.int)(x.Hwscale), cgoAllocsUnknown
	allocs5b975e14.Borrow(chwscale_allocs)

	var cscale2x_allocs *cgoAllocMap
	ref5b975e14.scale2x, cscale2x_allocs = (C.int)(x.Scale2x), cgoAllocsUnknown
	allocs5b975e14.Borrow(cscale2x_allocs)

	var cfilter_allocs *cgoAllocMap
	ref5b975e14.filter, cfilter_allocs = (C.int)(x.Filter), cgoAllocsUnknown
	allocs5b975e14.Borrow(cfilter_allocs)

	var cexternal_palette_allocs *cgoAllocMap
	ref5b975e14.external_palette, cexternal_palette_allocs = (C.int)(x.ExternalPalette), cgoAllocsUnknown
	allocs5b975e14.Borrow(cexternal_palette_allocs)

	var cexternal_palette_name_allocs *cgoAllocMap
	ref5b975e14.external_palette_name, cexternal_palette_name_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.ExternalPaletteName)).Data)), cgoAllocsUnknown
	allocs5b975e14.Borrow(cexternal_palette_name_allocs)

	var cdouble_buffer_allocs *cgoAllocMap
	ref5b975e14.double_buffer, cdouble_buffer_allocs = (C.int)(x.DoubleBuffer), cgoAllocsUnknown
	allocs5b975e14.Borrow(cdouble_buffer_allocs)

	var creadable_allocs *cgoAllocMap
	ref5b975e14.readable, creadable_allocs = (C.int)(x.Readable), cgoAllocsUnknown
	allocs5b975e14.Borrow(creadable_allocs)

	var ccbm_palette_allocs *cgoAllocMap
	ref5b975e14.cbm_palette, ccbm_palette_allocs = unpackSVideoCbmPaletteS(x.CbmPalette)
	allocs5b975e14.Borrow(ccbm_palette_allocs)

	var ccolor_tables_allocs *cgoAllocMap
	ref5b975e14.color_tables, ccolor_tables_allocs = x.ColorTables.PassValue()
	allocs5b975e14.Borrow(ccolor_tables_allocs)

	var cfullscreen_enabled_allocs *cgoAllocMap
	ref5b975e14.fullscreen_enabled, cfullscreen_enabled_allocs = (C.int)(x.FullscreenEnabled), cgoAllocsUnknown
	allocs5b975e14.Borrow(cfullscreen_enabled_allocs)

	var cfullscreen_statusbar_enabled_allocs *cgoAllocMap
	ref5b975e14.fullscreen_statusbar_enabled, cfullscreen_statusbar_enabled_allocs = (C.int)(x.FullscreenStatusbarEnabled), cgoAllocsUnknown
	allocs5b975e14.Borrow(cfullscreen_statusbar_enabled_allocs)

	var cfullscreen_device_allocs *cgoAllocMap
	ref5b975e14.fullscreen_device, cfullscreen_device_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.FullscreenDevice)).Data)), cgoAllocsUnknown
	allocs5b975e14.Borrow(cfullscreen_device_allocs)

	var cfullscreen_device_num_allocs *cgoAllocMap
	ref5b975e14.fullscreen_device_num, cfullscreen_device_num_allocs = (C.int)(x.FullscreenDeviceNum), cgoAllocsUnknown
	allocs5b975e14.Borrow(cfullscreen_device_num_allocs)

	var cfullscreen_double_size_enabled_allocs *cgoAllocMap
	ref5b975e14.fullscreen_double_size_enabled, cfullscreen_double_size_enabled_allocs = (C.int)(x.FullscreenDoubleSizeEnabled), cgoAllocsUnknown
	allocs5b975e14.Borrow(cfullscreen_double_size_enabled_allocs)

	var cfullscreen_double_scan_enabled_allocs *cgoAllocMap
	ref5b975e14.fullscreen_double_scan_enabled, cfullscreen_double_scan_enabled_allocs = (C.int)(x.FullscreenDoubleScanEnabled), cgoAllocsUnknown
	allocs5b975e14.Borrow(cfullscreen_double_scan_enabled_allocs)

	var cfullscreen_mode_allocs *cgoAllocMap
	ref5b975e14.fullscreen_mode, cfullscreen_mode_allocs = *(*[4]C.int)(unsafe.Pointer(&x.FullscreenMode)), cgoAllocsUnknown
	allocs5b975e14.Borrow(cfullscreen_mode_allocs)

	x.ref5b975e14 = ref5b975e14
	x.allocs5b975e14 = allocs5b975e14
	return ref5b975e14, allocs5b975e14

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoRenderConfig) PassValue() (C.video_render_config_t, *cgoAllocMap) {
	if x.ref5b975e14 != nil {
		return *x.ref5b975e14, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoRenderConfig) Deref() {
	if x.ref5b975e14 == nil {
		return
	}
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.ChipName))
	hxf95e7c8.Data = uintptr(unsafe.Pointer(x.ref5b975e14.chip_name))
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.VideoResources = *NewVideoResourcesRef(unsafe.Pointer(&x.ref5b975e14.video_resources))
	packSVideoChipCap(x.Cap, x.ref5b975e14.cap)
	x.Rendermode = (int32)(x.ref5b975e14.rendermode)
	x.DoubleSizeEnabled = (int32)(x.ref5b975e14.double_size_enabled)
	x.Scalex = (int32)(x.ref5b975e14.scalex)
	x.Scaley = (int32)(x.ref5b975e14.scaley)
	x.Doublescan = (int32)(x.ref5b975e14.doublescan)
	x.Hwscale = (int32)(x.ref5b975e14.hwscale)
	x.Scale2x = (int32)(x.ref5b975e14.scale2x)
	x.Filter = (int32)(x.ref5b975e14.filter)
	x.ExternalPalette = (int32)(x.ref5b975e14.external_palette)
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.ExternalPaletteName))
	hxff2234b.Data = uintptr(unsafe.Pointer(x.ref5b975e14.external_palette_name))
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.DoubleBuffer = (int32)(x.ref5b975e14.double_buffer)
	x.Readable = (int32)(x.ref5b975e14.readable)
	packSVideoCbmPaletteS(x.CbmPalette, x.ref5b975e14.cbm_palette)
	x.ColorTables = *NewVideoRenderColorTablesSRef(unsafe.Pointer(&x.ref5b975e14.color_tables))
	x.FullscreenEnabled = (int32)(x.ref5b975e14.fullscreen_enabled)
	x.FullscreenStatusbarEnabled = (int32)(x.ref5b975e14.fullscreen_statusbar_enabled)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.FullscreenDevice))
	hxff73280.Data = uintptr(unsafe.Pointer(x.ref5b975e14.fullscreen_device))
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.FullscreenDeviceNum = (int32)(x.ref5b975e14.fullscreen_device_num)
	x.FullscreenDoubleSizeEnabled = (int32)(x.ref5b975e14.fullscreen_double_size_enabled)
	x.FullscreenDoubleScanEnabled = (int32)(x.ref5b975e14.fullscreen_double_scan_enabled)
	x.FullscreenMode = *(*[4]int32)(unsafe.Pointer(&x.ref5b975e14.fullscreen_mode))
}

// allocVideoDrawBufferCallbackMemory allocates memory for type C.video_draw_buffer_callback_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoDrawBufferCallbackMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoDrawBufferCallbackValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVideoDrawBufferCallbackValue = unsafe.Sizeof([1]C.video_draw_buffer_callback_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoDrawBufferCallback) Ref() *C.video_draw_buffer_callback_t {
	if x == nil {
		return nil
	}
	return x.refb8dd2b44
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoDrawBufferCallback) Free() {
	if x != nil && x.allocsb8dd2b44 != nil {
		x.allocsb8dd2b44.(*cgoAllocMap).Free()
		x.refb8dd2b44 = nil
	}
}

// NewVideoDrawBufferCallbackRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoDrawBufferCallbackRef(ref unsafe.Pointer) *VideoDrawBufferCallback {
	if ref == nil {
		return nil
	}
	obj := new(VideoDrawBufferCallback)
	obj.refb8dd2b44 = (*C.video_draw_buffer_callback_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoDrawBufferCallback) PassRef() (*C.video_draw_buffer_callback_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8dd2b44 != nil {
		return x.refb8dd2b44, nil
	}
	memb8dd2b44 := allocVideoDrawBufferCallbackMemory(1)
	refb8dd2b44 := (*C.video_draw_buffer_callback_t)(memb8dd2b44)
	allocsb8dd2b44 := new(cgoAllocMap)
	var cdraw_buffer_alloc_allocs *cgoAllocMap
	refb8dd2b44.draw_buffer_alloc, cdraw_buffer_alloc_allocs = x.DrawBufferAlloc.PassRef()
	allocsb8dd2b44.Borrow(cdraw_buffer_alloc_allocs)

	var cdraw_buffer_free_allocs *cgoAllocMap
	refb8dd2b44.draw_buffer_free, cdraw_buffer_free_allocs = x.DrawBufferFree.PassRef()
	allocsb8dd2b44.Borrow(cdraw_buffer_free_allocs)

	var cdraw_buffer_clear_allocs *cgoAllocMap
	refb8dd2b44.draw_buffer_clear, cdraw_buffer_clear_allocs = x.DrawBufferClear.PassRef()
	allocsb8dd2b44.Borrow(cdraw_buffer_clear_allocs)

	x.refb8dd2b44 = refb8dd2b44
	x.allocsb8dd2b44 = allocsb8dd2b44
	return refb8dd2b44, allocsb8dd2b44

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoDrawBufferCallback) PassValue() (C.video_draw_buffer_callback_t, *cgoAllocMap) {
	if x.refb8dd2b44 != nil {
		return *x.refb8dd2b44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoDrawBufferCallback) Deref() {
	if x.refb8dd2b44 == nil {
		return
	}
	x.DrawBufferAlloc = NewRef(unsafe.Pointer(x.refb8dd2b44.draw_buffer_alloc))
	x.DrawBufferFree = NewRef(unsafe.Pointer(x.refb8dd2b44.draw_buffer_free))
	x.DrawBufferClear = NewRef(unsafe.Pointer(x.refb8dd2b44.draw_buffer_clear))
}

// allocVideoCbmColorMemory allocates memory for type C.video_cbm_color_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoCbmColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoCbmColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVideoCbmColorValue = unsafe.Sizeof([1]C.video_cbm_color_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoCbmColor) Ref() *C.video_cbm_color_t {
	if x == nil {
		return nil
	}
	return x.ref354e7dce
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoCbmColor) Free() {
	if x != nil && x.allocs354e7dce != nil {
		x.allocs354e7dce.(*cgoAllocMap).Free()
		x.ref354e7dce = nil
	}
}

// NewVideoCbmColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoCbmColorRef(ref unsafe.Pointer) *VideoCbmColor {
	if ref == nil {
		return nil
	}
	obj := new(VideoCbmColor)
	obj.ref354e7dce = (*C.video_cbm_color_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoCbmColor) PassRef() (*C.video_cbm_color_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref354e7dce != nil {
		return x.ref354e7dce, nil
	}
	mem354e7dce := allocVideoCbmColorMemory(1)
	ref354e7dce := (*C.video_cbm_color_t)(mem354e7dce)
	allocs354e7dce := new(cgoAllocMap)
	var cluminance_allocs *cgoAllocMap
	ref354e7dce.luminance, cluminance_allocs = (C.float)(x.Luminance), cgoAllocsUnknown
	allocs354e7dce.Borrow(cluminance_allocs)

	var cangle_allocs *cgoAllocMap
	ref354e7dce.angle, cangle_allocs = (C.float)(x.Angle), cgoAllocsUnknown
	allocs354e7dce.Borrow(cangle_allocs)

	var cdirection_allocs *cgoAllocMap
	ref354e7dce.direction, cdirection_allocs = (C.int)(x.Direction), cgoAllocsUnknown
	allocs354e7dce.Borrow(cdirection_allocs)

	var cname_allocs *cgoAllocMap
	ref354e7dce.name, cname_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Name)).Data)), cgoAllocsUnknown
	allocs354e7dce.Borrow(cname_allocs)

	x.ref354e7dce = ref354e7dce
	x.allocs354e7dce = allocs354e7dce
	return ref354e7dce, allocs354e7dce

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoCbmColor) PassValue() (C.video_cbm_color_t, *cgoAllocMap) {
	if x.ref354e7dce != nil {
		return *x.ref354e7dce, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoCbmColor) Deref() {
	if x.ref354e7dce == nil {
		return
	}
	x.Luminance = (float32)(x.ref354e7dce.luminance)
	x.Angle = (float32)(x.ref354e7dce.angle)
	x.Direction = (int32)(x.ref354e7dce.direction)
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.Name))
	hxfa9955c.Data = uintptr(unsafe.Pointer(x.ref354e7dce.name))
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

}

// allocVideoCbmPaletteMemory allocates memory for type C.video_cbm_palette_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoCbmPaletteMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoCbmPaletteValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVideoCbmPaletteValue = unsafe.Sizeof([1]C.video_cbm_palette_t{})

// unpackSVideoCbmColor transforms a sliced Go data structure into plain C format.
func unpackSVideoCbmColor(x []VideoCbmColor) (unpacked *C.video_cbm_color_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.video_cbm_color_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVideoCbmColorMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.video_cbm_color_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.video_cbm_color_t)(unsafe.Pointer(h.Data))
	return
}

// packSVideoCbmColor reads sliced Go data structure out from plain C format.
func packSVideoCbmColor(v []VideoCbmColor, ptr0 *C.video_cbm_color_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVideoCbmColorValue]C.video_cbm_color_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVideoCbmColorRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoCbmPalette) Ref() *C.video_cbm_palette_t {
	if x == nil {
		return nil
	}
	return x.ref94947f76
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoCbmPalette) Free() {
	if x != nil && x.allocs94947f76 != nil {
		x.allocs94947f76.(*cgoAllocMap).Free()
		x.ref94947f76 = nil
	}
}

// NewVideoCbmPaletteRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoCbmPaletteRef(ref unsafe.Pointer) *VideoCbmPalette {
	if ref == nil {
		return nil
	}
	obj := new(VideoCbmPalette)
	obj.ref94947f76 = (*C.video_cbm_palette_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoCbmPalette) PassRef() (*C.video_cbm_palette_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref94947f76 != nil {
		return x.ref94947f76, nil
	}
	mem94947f76 := allocVideoCbmPaletteMemory(1)
	ref94947f76 := (*C.video_cbm_palette_t)(mem94947f76)
	allocs94947f76 := new(cgoAllocMap)
	var cnum_entries_allocs *cgoAllocMap
	ref94947f76.num_entries, cnum_entries_allocs = (C.uint)(x.NumEntries), cgoAllocsUnknown
	allocs94947f76.Borrow(cnum_entries_allocs)

	var centries_allocs *cgoAllocMap
	ref94947f76.entries, centries_allocs = unpackSVideoCbmColor(x.Entries)
	allocs94947f76.Borrow(centries_allocs)

	var csaturation_allocs *cgoAllocMap
	ref94947f76.saturation, csaturation_allocs = (C.float)(x.Saturation), cgoAllocsUnknown
	allocs94947f76.Borrow(csaturation_allocs)

	var cphase_allocs *cgoAllocMap
	ref94947f76.phase, cphase_allocs = (C.float)(x.Phase), cgoAllocsUnknown
	allocs94947f76.Borrow(cphase_allocs)

	var c_type_allocs *cgoAllocMap
	ref94947f76._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs94947f76.Borrow(c_type_allocs)

	x.ref94947f76 = ref94947f76
	x.allocs94947f76 = allocs94947f76
	return ref94947f76, allocs94947f76

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoCbmPalette) PassValue() (C.video_cbm_palette_t, *cgoAllocMap) {
	if x.ref94947f76 != nil {
		return *x.ref94947f76, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoCbmPalette) Deref() {
	if x.ref94947f76 == nil {
		return
	}
	x.NumEntries = (uint32)(x.ref94947f76.num_entries)
	packSVideoCbmColor(x.Entries, x.ref94947f76.entries)
	x.Saturation = (float32)(x.ref94947f76.saturation)
	x.Phase = (float32)(x.ref94947f76.phase)
	x.Type = (int32)(x.ref94947f76._type)
}

// allocDiskImageMemory allocates memory for type C.disk_image_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDiskImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDiskImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDiskImageValue = unsafe.Sizeof([1]C.disk_image_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DiskImage) Ref() *C.disk_image_t {
	if x == nil {
		return nil
	}
	return x.refb8e680ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DiskImage) Free() {
	if x != nil && x.allocsb8e680ad != nil {
		x.allocsb8e680ad.(*cgoAllocMap).Free()
		x.refb8e680ad = nil
	}
}

// NewDiskImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDiskImageRef(ref unsafe.Pointer) *DiskImage {
	if ref == nil {
		return nil
	}
	obj := new(DiskImage)
	obj.refb8e680ad = (*C.disk_image_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DiskImage) PassRef() (*C.disk_image_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8e680ad != nil {
		return x.refb8e680ad, nil
	}
	memb8e680ad := allocDiskImageMemory(1)
	refb8e680ad := (*C.disk_image_t)(memb8e680ad)
	allocsb8e680ad := new(cgoAllocMap)
	var cread_only_allocs *cgoAllocMap
	refb8e680ad.read_only, cread_only_allocs = (C.uint)(x.ReadOnly), cgoAllocsUnknown
	allocsb8e680ad.Borrow(cread_only_allocs)

	var cdevice_allocs *cgoAllocMap
	refb8e680ad.device, cdevice_allocs = (C.uint)(x.Device), cgoAllocsUnknown
	allocsb8e680ad.Borrow(cdevice_allocs)

	var c_type_allocs *cgoAllocMap
	refb8e680ad._type, c_type_allocs = (C.uint)(x.Type), cgoAllocsUnknown
	allocsb8e680ad.Borrow(c_type_allocs)

	var ctracks_allocs *cgoAllocMap
	refb8e680ad.tracks, ctracks_allocs = (C.uint)(x.Tracks), cgoAllocsUnknown
	allocsb8e680ad.Borrow(ctracks_allocs)

	var cmax_half_tracks_allocs *cgoAllocMap
	refb8e680ad.max_half_tracks, cmax_half_tracks_allocs = (C.uint)(x.MaxHalfTracks), cgoAllocsUnknown
	allocsb8e680ad.Borrow(cmax_half_tracks_allocs)

	x.refb8e680ad = refb8e680ad
	x.allocsb8e680ad = allocsb8e680ad
	return refb8e680ad, allocsb8e680ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DiskImage) PassValue() (C.disk_image_t, *cgoAllocMap) {
	if x.refb8e680ad != nil {
		return *x.refb8e680ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DiskImage) Deref() {
	if x.refb8e680ad == nil {
		return
	}
	x.ReadOnly = (uint32)(x.refb8e680ad.read_only)
	x.Device = (uint32)(x.refb8e680ad.device)
	x.Type = (uint32)(x.refb8e680ad._type)
	x.Tracks = (uint32)(x.refb8e680ad.tracks)
	x.MaxHalfTracks = (uint32)(x.refb8e680ad.max_half_tracks)
}

func (x MonitorToggleFunc) PassRef() (ref *C.monitor_toggle_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if monitorToggleFuncCF2E566AFunc == nil {
		monitorToggleFuncCF2E566AFunc = x
	}
	return (*C.monitor_toggle_func_t)(C.monitor_toggle_func_t_cf2e566a), nil
}

func NewMonitorToggleFuncRef(ref unsafe.Pointer) *MonitorToggleFunc {
	return (*MonitorToggleFunc)(ref)
}

//export monitorToggleFuncCF2E566A
func monitorToggleFuncCF2E566A(cvalue C.int) {
	if monitorToggleFuncCF2E566AFunc != nil {
		valuecf2e566a := (int32)(cvalue)
		monitorToggleFuncCF2E566AFunc(valuecf2e566a)
		return
	}
	panic("callback func has not been set (race?)")
}

var monitorToggleFuncCF2E566AFunc MonitorToggleFunc

// Ref returns a reference to C object as it is.
func (x *VideoCanvasS) Ref() *C.struct_video_canvas_s {
	if x == nil {
		return nil
	}
	return (*C.struct_video_canvas_s)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *VideoCanvasS) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewVideoCanvasSRef converts the C object reference into a raw struct reference without wrapping.
func NewVideoCanvasSRef(ref unsafe.Pointer) *VideoCanvasS {
	return (*VideoCanvasS)(ref)
}

// NewVideoCanvasS allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewVideoCanvasS() *VideoCanvasS {
	return (*VideoCanvasS)(allocStructVideoCanvasSMemory(1))
}

// allocStructVideoCanvasSMemory allocates memory for type C.struct_video_canvas_s in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructVideoCanvasSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructVideoCanvasSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructVideoCanvasSValue = unsafe.Sizeof([1]C.struct_video_canvas_s{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *VideoCanvasS) PassRef() *C.struct_video_canvas_s {
	if x == nil {
		x = (*VideoCanvasS)(allocStructVideoCanvasSMemory(1))
	}
	return (*C.struct_video_canvas_s)(unsafe.Pointer(x))
}

// unpackArgSMonitorInterface transforms a sliced Go data structure into plain C format.
func unpackArgSMonitorInterface(x []MonitorInterface) (unpacked *C.monitor_interface_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.monitor_interface_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMonitorInterfaceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.monitor_interface_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.monitor_interface_t)(unsafe.Pointer(h.Data))
	return
}

// packSMonitorInterface reads sliced Go data structure out from plain C format.
func packSMonitorInterface(v []MonitorInterface, ptr0 *C.monitor_interface_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMonitorInterfaceValue]C.monitor_interface_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMonitorInterfaceRef(unsafe.Pointer(&ptr1))
	}
}

// allocPMonitorInterfaceMemory allocates memory for type *C.monitor_interface_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPMonitorInterfaceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPMonitorInterfaceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPMonitorInterfaceValue = unsafe.Sizeof([1]*C.monitor_interface_t{})

// unpackArgSSMonitorInterface transforms a sliced Go data structure into plain C format.
func unpackArgSSMonitorInterface(x [][]MonitorInterface) (unpacked **C.monitor_interface_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.monitor_interface_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPMonitorInterfaceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.monitor_interface_t)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocMonitorInterfaceMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: uintptr(mem1),
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.monitor_interface_t)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			v1[i1], _ = x[i0][i1].PassValue()
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.monitor_interface_t)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.monitor_interface_t)(unsafe.Pointer(h.Data))
	return
}

// packSSMonitorInterface reads sliced Go data structure out from plain C format.
func packSSMonitorInterface(v [][]MonitorInterface, ptr0 **C.monitor_interface_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.monitor_interface_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfMonitorInterfaceValue]C.monitor_interface_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewMonitorInterfaceRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPStructMonitorCpuTypeSMemory allocates memory for type *C.struct_monitor_cpu_type_s in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructMonitorCpuTypeSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructMonitorCpuTypeSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPStructMonitorCpuTypeSValue = unsafe.Sizeof([1]*C.struct_monitor_cpu_type_s{})

// allocStructMonitorCpuTypeSMemory allocates memory for type C.struct_monitor_cpu_type_s in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructMonitorCpuTypeSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructMonitorCpuTypeSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructMonitorCpuTypeSValue = unsafe.Sizeof([1]C.struct_monitor_cpu_type_s{})

// unpackArgSSMonitorCpuTypeS transforms a sliced Go data structure into plain C format.
func unpackArgSSMonitorCpuTypeS(x [][]MonitorCpuTypeS) (unpacked **C.struct_monitor_cpu_type_s, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.struct_monitor_cpu_type_s) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPStructMonitorCpuTypeSMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_monitor_cpu_type_s)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocStructMonitorCpuTypeSMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: uintptr(mem1),
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.struct_monitor_cpu_type_s)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			v1[i1], _ = x[i0][i1].PassValue()
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.struct_monitor_cpu_type_s)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_monitor_cpu_type_s)(unsafe.Pointer(h.Data))
	return
}

// packSSMonitorCpuTypeS reads sliced Go data structure out from plain C format.
func packSSMonitorCpuTypeS(v [][]MonitorCpuTypeS, ptr0 **C.struct_monitor_cpu_type_s) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_monitor_cpu_type_s)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfStructMonitorCpuTypeSValue]C.struct_monitor_cpu_type_s)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewMonitorCpuTypeSRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPUcharMemory allocates memory for type *C.uchar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUcharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPUcharValue = unsafe.Sizeof([1]*C.uchar{})

// unpackArgSSByte transforms a sliced Go data structure into plain C format.
func unpackArgSSByte(x [][]byte) (unpacked **C.uchar, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.uchar) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPUcharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uchar)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uchar)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uchar)(unsafe.Pointer(h.Data))
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.uchar) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uchar)(unsafe.Pointer(ptr0)))[i0]
		hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfa3f05c.Data = uintptr(unsafe.Pointer(ptr1))
		hxfa3f05c.Cap = 0x7fffffff
		// hxfa3f05c.Len = ?
	}
}

// unpackArgSVideoRenderConfig transforms a sliced Go data structure into plain C format.
func unpackArgSVideoRenderConfig(x []VideoRenderConfig) (unpacked *C.video_render_config_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.video_render_config_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVideoRenderConfigMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.video_render_config_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.video_render_config_t)(unsafe.Pointer(h.Data))
	return
}

// packSVideoRenderConfig reads sliced Go data structure out from plain C format.
func packSVideoRenderConfig(v []VideoRenderConfig, ptr0 *C.video_render_config_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVideoRenderConfigValue]C.video_render_config_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVideoRenderConfigRef(unsafe.Pointer(&ptr1))
	}
}

// allocStructVideoRenderConfigSMemory allocates memory for type C.struct_video_render_config_s in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructVideoRenderConfigSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructVideoRenderConfigSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructVideoRenderConfigSValue = unsafe.Sizeof([1]C.struct_video_render_config_s{})

// unpackArgSVideoRenderConfigS transforms a sliced Go data structure into plain C format.
func unpackArgSVideoRenderConfigS(x []VideoRenderConfigS) (unpacked *C.struct_video_render_config_s, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_video_render_config_s) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructVideoRenderConfigSMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_video_render_config_s)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_video_render_config_s)(unsafe.Pointer(h.Data))
	return
}

// packSVideoRenderConfigS reads sliced Go data structure out from plain C format.
func packSVideoRenderConfigS(v []VideoRenderConfigS, ptr0 *C.struct_video_render_config_s) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructVideoRenderConfigSValue]C.struct_video_render_config_s)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVideoRenderConfigSRef(unsafe.Pointer(&ptr1))
	}
}

// allocPStructViewportSMemory allocates memory for type *C.struct_viewport_s in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructViewportSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructViewportSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPStructViewportSValue = unsafe.Sizeof([1]*C.struct_viewport_s{})

// unpackArgSSViewportS transforms a sliced Go data structure into plain C format.
func unpackArgSSViewportS(x [][]ViewportS) (unpacked **C.struct_viewport_s, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.struct_viewport_s) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPStructViewportSMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_viewport_s)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.struct_viewport_s)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_viewport_s)(unsafe.Pointer(h.Data))
	return
}

// packSSViewportS reads sliced Go data structure out from plain C format.
func packSSViewportS(v [][]ViewportS, ptr0 **C.struct_viewport_s) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_viewport_s)(unsafe.Pointer(ptr0)))[i0]
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf0d18b7.Data = uintptr(unsafe.Pointer(ptr1))
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?
	}
}

// allocPStructGeometrySMemory allocates memory for type *C.struct_geometry_s in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructGeometrySMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructGeometrySValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPStructGeometrySValue = unsafe.Sizeof([1]*C.struct_geometry_s{})

// unpackArgSSGeometryS transforms a sliced Go data structure into plain C format.
func unpackArgSSGeometryS(x [][]GeometryS) (unpacked **C.struct_geometry_s, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.struct_geometry_s) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPStructGeometrySMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_geometry_s)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.struct_geometry_s)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_geometry_s)(unsafe.Pointer(h.Data))
	return
}

// packSSGeometryS reads sliced Go data structure out from plain C format.
func packSSGeometryS(v [][]GeometryS, ptr0 **C.struct_geometry_s) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_geometry_s)(unsafe.Pointer(ptr0)))[i0]
		hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf2fab0d.Data = uintptr(unsafe.Pointer(ptr1))
		hxf2fab0d.Cap = 0x7fffffff
		// hxf2fab0d.Len = ?
	}
}

// allocPStructVideoCanvasSMemory allocates memory for type *C.struct_video_canvas_s in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructVideoCanvasSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructVideoCanvasSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPStructVideoCanvasSValue = unsafe.Sizeof([1]*C.struct_video_canvas_s{})

// unpackArgSSVideoCanvasS transforms a sliced Go data structure into plain C format.
func unpackArgSSVideoCanvasS(x [][]VideoCanvasS) (unpacked **C.struct_video_canvas_s, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.struct_video_canvas_s) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPStructVideoCanvasSMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_video_canvas_s)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.struct_video_canvas_s)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_video_canvas_s)(unsafe.Pointer(h.Data))
	return
}

// packSSVideoCanvasS reads sliced Go data structure out from plain C format.
func packSSVideoCanvasS(v [][]VideoCanvasS, ptr0 **C.struct_video_canvas_s) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_video_canvas_s)(unsafe.Pointer(ptr0)))[i0]
		hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf69fe70.Data = uintptr(unsafe.Pointer(ptr1))
		hxf69fe70.Cap = 0x7fffffff
		// hxf69fe70.Len = ?
	}
}

// unpackArgSVideoChipCap transforms a sliced Go data structure into plain C format.
func unpackArgSVideoChipCap(x []VideoChipCap) (unpacked *C.video_chip_cap_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.video_chip_cap_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVideoChipCapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.video_chip_cap_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.video_chip_cap_t)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSVideoCbmPaletteS transforms a sliced Go data structure into plain C format.
func unpackArgSVideoCbmPaletteS(x []VideoCbmPaletteS) (unpacked *C.struct_video_cbm_palette_s, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_video_cbm_palette_s) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructVideoCbmPaletteSMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_video_cbm_palette_s)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_video_cbm_palette_s)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSDiskImage transforms a sliced Go data structure into plain C format.
func unpackArgSDiskImage(x []DiskImage) (unpacked *C.disk_image_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.disk_image_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDiskImageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.disk_image_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.disk_image_t)(unsafe.Pointer(h.Data))
	return
}

// packSDiskImage reads sliced Go data structure out from plain C format.
func packSDiskImage(v []DiskImage, ptr0 *C.disk_image_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDiskImageValue]C.disk_image_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDiskImageRef(unsafe.Pointer(&ptr1))
	}
}

// allocDiskAddrMemory allocates memory for type C.disk_addr_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDiskAddrMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDiskAddrValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDiskAddrValue = unsafe.Sizeof([1]C.disk_addr_t{})

// unpackArgSDiskAddr transforms a sliced Go data structure into plain C format.
func unpackArgSDiskAddr(x []DiskAddr) (unpacked *C.disk_addr_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.disk_addr_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDiskAddrMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.disk_addr_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.disk_addr_t)(unsafe.Pointer(h.Data))
	return
}

// packSDiskAddr reads sliced Go data structure out from plain C format.
func packSDiskAddr(v []DiskAddr, ptr0 *C.disk_addr_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDiskAddrValue]C.disk_addr_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDiskAddrRef(unsafe.Pointer(&ptr1))
	}
}

// unpackPUcharString represents the data from Go string as *C.uchar and avoids copying.
func unpackPUcharString(str string) (*C.uchar, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.uchar)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

// allocStructCondNodeSMemory allocates memory for type C.struct_cond_node_s in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructCondNodeSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructCondNodeSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructCondNodeSValue = unsafe.Sizeof([1]C.struct_cond_node_s{})

// unpackArgSCondNodeS transforms a sliced Go data structure into plain C format.
func unpackArgSCondNodeS(x []CondNodeS) (unpacked *C.struct_cond_node_s, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_cond_node_s) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructCondNodeSMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_cond_node_s)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_cond_node_s)(unsafe.Pointer(h.Data))
	return
}

// packSCondNodeS reads sliced Go data structure out from plain C format.
func packSCondNodeS(v []CondNodeS, ptr0 *C.struct_cond_node_s) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructCondNodeSValue]C.struct_cond_node_s)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCondNodeSRef(unsafe.Pointer(&ptr1))
	}
}
